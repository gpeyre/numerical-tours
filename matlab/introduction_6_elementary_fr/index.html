
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><p style="font-size:0px">
         \[
         \newcommand{\NN}{\mathbb{N}}
         \newcommand{\CC}{\mathbb{C}}
         \newcommand{\GG}{\mathbb{G}}
         \newcommand{\LL}{\mathbb{L}}
         \newcommand{\PP}{\mathbb{P}}
         \newcommand{\QQ}{\mathbb{Q}}
         \newcommand{\RR}{\mathbb{R}}
         \newcommand{\VV}{\mathbb{V}}
         \newcommand{\ZZ}{\mathbb{Z}}
         \newcommand{\FF}{\mathbb{F}}
         \newcommand{\KK}{\mathbb{K}}
         \newcommand{\UU}{\mathbb{U}}
         \newcommand{\EE}{\mathbb{E}}
         
         \newcommand{\Aa}{\mathcal{A}}
         \newcommand{\Bb}{\mathcal{B}}
         \newcommand{\Cc}{\mathcal{C}}
         \newcommand{\Dd}{\mathcal{D}}
         \newcommand{\Ee}{\mathcal{E}}
         \newcommand{\Ff}{\mathcal{F}}
         \newcommand{\Gg}{\mathcal{G}}
         \newcommand{\Hh}{\mathcal{H}}
         \newcommand{\Ii}{\mathcal{I}}
         \newcommand{\Jj}{\mathcal{J}}
         \newcommand{\Kk}{\mathcal{K}}
         \newcommand{\Ll}{\mathcal{L}}
         \newcommand{\Mm}{\mathcal{M}}
         \newcommand{\Nn}{\mathcal{N}}
         \newcommand{\Oo}{\mathcal{O}}
         \newcommand{\Pp}{\mathcal{P}}
         \newcommand{\Qq}{\mathcal{Q}}
         \newcommand{\Rr}{\mathcal{R}}
         \newcommand{\Ss}{\mathcal{S}}
         \newcommand{\Tt}{\mathcal{T}}
         \newcommand{\Uu}{\mathcal{U}}
         \newcommand{\Vv}{\mathcal{V}}
         \newcommand{\Ww}{\mathcal{W}}
         \newcommand{\Xx}{\mathcal{X}}
         \newcommand{\Yy}{\mathcal{Y}}
         \newcommand{\Zz}{\mathcal{Z}}
         
         \newcommand{\al}{\alpha}
         \newcommand{\la}{\lambda}
         \newcommand{\ga}{\gamma}
         \newcommand{\Ga}{\Gamma}
         \newcommand{\La}{\Lambda}
         \newcommand{\Si}{\Sigma}
         \newcommand{\si}{\sigma}
         \newcommand{\be}{\beta}
         \newcommand{\de}{\delta}
         \newcommand{\De}{\Delta}
         \renewcommand{\phi}{\varphi}
         \renewcommand{\th}{\theta}
         \newcommand{\om}{\omega}
         \newcommand{\Om}{\Omega}
         \renewcommand{\epsilon}{\varepsilon}
         
         \newcommand{\Calpha}{\mathrm{C}^\al}
         \newcommand{\Cbeta}{\mathrm{C}^\be}
         \newcommand{\Cal}{\text{C}^\al}
         \newcommand{\Cdeux}{\text{C}^{2}}
         \newcommand{\Cun}{\text{C}^{1}}
         \newcommand{\Calt}[1]{\text{C}^{#1}}
         
         \newcommand{\lun}{\ell^1}
         \newcommand{\ldeux}{\ell^2}
         \newcommand{\linf}{\ell^\infty}
         \newcommand{\ldeuxj}{{\ldeux_j}}
         \newcommand{\Lun}{\text{\upshape L}^1}
         \newcommand{\Ldeux}{\text{\upshape L}^2}
         \newcommand{\Lp}{\text{\upshape L}^p}
         \newcommand{\Lq}{\text{\upshape L}^q}
         \newcommand{\Linf}{\text{\upshape L}^\infty}
         \newcommand{\lzero}{\ell^0}
         \newcommand{\lp}{\ell^p}
         
         
         \renewcommand{\d}{\ins{d}}
         
         \newcommand{\Grad}{\text{Grad}}
         \newcommand{\grad}{\text{grad}}
         \renewcommand{\div}{\text{div}}
         \newcommand{\diag}{\text{diag}}
         
         \newcommand{\pd}[2]{ \frac{ \partial #1}{\partial #2} }
         \newcommand{\pdd}[2]{ \frac{ \partial^2 #1}{\partial #2^2} }
         
         \newcommand{\dotp}[2]{\langle #1,\,#2\rangle}
         \newcommand{\norm}[1]{|\!| #1 |\!|}
         \newcommand{\normi}[1]{\norm{#1}_{\infty}}
         \newcommand{\normu}[1]{\norm{#1}_{1}}
         \newcommand{\normz}[1]{\norm{#1}_{0}}
         \newcommand{\abs}[1]{\vert #1 \vert}
         
         
         \newcommand{\argmin}{\text{argmin}}
         \newcommand{\argmax}{\text{argmax}}
         \newcommand{\uargmin}[1]{\underset{#1}{\argmin}\;}
         \newcommand{\uargmax}[1]{\underset{#1}{\argmax}\;}
         \newcommand{\umin}[1]{\underset{#1}{\min}\;}
         \newcommand{\umax}[1]{\underset{#1}{\max}\;}
         
         \newcommand{\pa}[1]{\left( #1 \right)}
         \newcommand{\choice}[1]{ \left\{  \begin{array}{l} #1 \end{array} \right. }
         
         \newcommand{\enscond}[2]{ \left\{ #1 \;:\; #2 \right\} }
         
         \newcommand{\qandq}{ \quad \text{and} \quad }
         \newcommand{\qqandqq}{ \qquad \text{and} \qquad }
         \newcommand{\qifq}{ \quad \text{if} \quad }
         \newcommand{\qqifqq}{ \qquad \text{if} \qquad }
         \newcommand{\qwhereq}{ \quad \text{where} \quad }
         \newcommand{\qqwhereqq}{ \qquad \text{where} \qquad }
         \newcommand{\qwithq}{ \quad \text{with} \quad }
         \newcommand{\qqwithqq}{ \qquad \text{with} \qquad }
         \newcommand{\qforq}{ \quad \text{for} \quad }
         \newcommand{\qqforqq}{ \qquad \text{for} \qquad }
         \newcommand{\qqsinceqq}{ \qquad \text{since} \qquad }
         \newcommand{\qsinceq}{ \quad \text{since} \quad }
         \newcommand{\qarrq}{\quad\Longrightarrow\quad}
         \newcommand{\qqarrqq}{\quad\Longrightarrow\quad}
         \newcommand{\qiffq}{\quad\Longleftrightarrow\quad}
         \newcommand{\qqiffqq}{\qquad\Longleftrightarrow\qquad}
         \newcommand{\qsubjq}{ \quad \text{subject to} \quad }
         \newcommand{\qqsubjqq}{ \qquad \text{subject to} \qquad }
         \]
         
      </p>
      <title>Le traitement num&eacute;rique des images</title>
      <NOSCRIPT>
         <DIV STYLE="color:#CC0000; text-align:center"><B>Warning: <A HREF="http://www.math.union.edu/locate/jsMath">jsMath</A> 
               	requires JavaScript to process the mathematics on this page.<BR> 
               	If your browser supports JavaScript, be sure it is enabled.</B></DIV>
         <HR>
      </NOSCRIPT>
      <meta name="generator" content="MATLAB 8.2">
      <meta name="date" content="2014-10-20">
      <meta name="m-file" content="index">
      <LINK REL="stylesheet" HREF="../style.css" TYPE="text/css">
   </head>
   <body>
      <div class="content">
         <h1>Le traitement num&eacute;rique des images</h1>
         <introduction>
            <p>Cette page reprend <a href="http://images.math.cnrs.fr/Le-traitement-numerique-des-images.html">l'article publi&eacute; sur le site web Images des math&eacute;matiques</a>.
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#4">Installing toolboxes and setting up the path.</a></li>
               <li><a href="#11">Les pixels d'une image</a></li>
               <li><a href="#17">Stocker une image</a></li>
               <li><a href="#23">La r&eacute;solution d'une image</a></li>
               <li><a href="#28">Quantifier une image</a></li>
               <li><a href="#37">Enlever le bruit par moyennes locales</a></li>
               <li><a href="#44">Enlever le bruit par m&eacute;diane</a></li>
               <li><a href="#51">D&eacute;tecter les bords des objets</a></li>
               <li><a href="#58">Les images couleurs</a></li>
               <li><a href="#67">Changer le contraste d'une image</a></li>
               <li><a href="#75">Transformations g&eacute;om&eacute;triques</a></li>
               <li><a href="#82">Fondu entres deux images</a></li>
               <li><a href="#89">Conclusion</a></li>
               <li><a href="#91">Glossaire</a></li>
            </ul>
         </div>
         <p>Les appareils num&eacute;riques photographient de mani&egrave;re tr&egrave;s pr&eacute;cise le monde qui nous entoure. L'utilisateur souhaite pouvoir
            stocker avec un encombrement minimal ses photos sur son disque dur. Il souhaite &eacute;galement pouvoir les retoucher afin d'am&eacute;liorer
            leur qualit&eacute;. Cet article pr&eacute;sente les outils math&eacute;matiques et informatiques qui permettent d'effectuer ces diff&eacute;rentes t&acirc;ches.
         </p>
         <p>Cet article pr&eacute;sente quelques concepts du <a href="http://fr.wikipedia.org/wiki/Traitement_d'images">traitement</a> math&eacute;matique des images num&eacute;riques. Ces traitements permettent de stocker plus facilement les images et d'am&eacute;liorer leur
            qualit&eacute;. Les math&eacute;matiques utilis&eacute;es dans cet article correspondent au niveau de la classe de troisi&egrave;me. Les mots cl&eacute;s en
            rouge pointent vers les pages <a href="http://fr.wikipedia.org/">Wikip&eacute;dia</a> correspondantes. Ils sont repris &agrave; la fin de l'article dans un glossaire.
         </p>
         <p><i>Mot clefs :</i> image, bits, carr&eacute;, racine carr&eacute;e, inverse, logarithme, moyenne, m&eacute;diane.
         </p>
         <h2>Installing toolboxes and setting up the path.<a name="4"></a></h2>
         <p>You need to download the following files: <a href="../toolbox_signal.zip">signal toolbox</a> and <a href="../toolbox_general.zip">general toolbox</a>.
         </p>
         <p>You need to unzip these toolboxes in your working directory, so that you have <tt>toolbox_signal</tt> and <tt>toolbox_general</tt> in your directory.
         </p>
         <p><b>For Scilab user:</b> you must replace the Matlab comment '%' by its Scilab counterpart '//'.
         </p>
         <p><b>Recommandation:</b> You should create a text file named for instance <tt>numericaltour.sce</tt> (in Scilab) or <tt>numericaltour.m</tt> (in Matlab) to write all the Scilab/Matlab command you want to execute. Then, simply run <tt>exec('numericaltour.sce');</tt> (in Scilab) or <tt>numericaltour;</tt> (in Matlab) to run the commands.
         </p>
         <p>Execute this line only if you are using Matlab.</p><pre class="codeinput">getd = @(p)path(p,path); <span class="comment">% scilab users must *not* execute this</span>
</pre><p>Then you can add the toolboxes to the path.</p><pre class="codeinput">getd(<span class="string">'toolbox_signal/'</span>);
getd(<span class="string">'toolbox_general/'</span>);
</pre><h2>Les pixels d'une image<a name="11"></a></h2>
         <p>Une <a href="http://fr.wikipedia.org/wiki/Image_num%C3%A9rique">image num&eacute;rique</a> en niveaux de gris est un tableau de valeurs. Chaque case de ce tableau, qui stocke une valeur, se nomme un <a href="http://fr.wikipedia.org/wiki/Pixel">pixel</a>. En notant \(n\) le nombre de lignes et \(p\) le nombre de colonnes de l'image, on manipule ainsi un tableau de \(n \times
            p\) pixels.
         </p>
         <p>La figure ci-dessous montre une visualisation d'un tableau carr&eacute; avec \(n=p=240\), ce qui repr&eacute;sente  \(240\times 240\)=57600
            pixels. Les <a href="http://fr.wikipedia.org/wiki/Appareil_photographique_num%C3%A9rique">appareils photos num&eacute;riques</a> peuvent enregistrer des images beaucoup plus grandes, avec plusieurs <a href="http://en.wikipedia.org/wiki/Gigapixel_image">millions de pixels</a>.
         </p><pre class="codeinput">n = 256;
name = <span class="string">'hibiscus'</span>;
f = load_image(name, n);
f = rescale(sum(f,3));
clf;
imageplot(f);
</pre><img vspace="5" hspace="5" src="index_01.png"> <p>Les valeurs des pixels sont enregistr&eacute;es dans <a href="http://fr.wikipedia.org/wiki/Ordinateur">l'ordinateur</a> ou <a href="http://fr.wikipedia.org/wiki/Appareil_photographique_num%C3%A9rique">l'appareil photo num&eacute;rique</a> sous forme de <a href="http://fr.wikipedia.org/wiki/Entier_relatif">nombres entiers</a> entre 0 et 255, ce qui fait 256 valeurs possibles pour chaque pixel.
         </p>
         <p>La valeur 0 correspond au noir, et la valeur 255 correspond au blanc. Les valeurs interm&eacute;diaires correspondent &agrave; des <a href="http://fr.wikipedia.org/wiki/Niveau_de_gris">niveaux de gris</a> allant du noir au blanc.
         </p>
         <p>La figure ci-dessous montre un sous-tableau de \(6 \times 6\) pixels extrait de l'image pr&eacute;c&eacute;dente. On peut voir &agrave; la fois
            les valeurs qui composent le tableau et les niveaux de gris qui permettent d'afficher l'image &agrave; l'&eacute;cran.
         </p><pre class="codeinput">selx = 19:24;
sely = 62:67;
clf;
image(f(selx,sely)*255); axis <span class="string">image</span>; axis <span class="string">off</span>;
disp(floor(255*f(selx,sely)));
</pre><pre class="codeoutput">    43    43    43    41    40    39
    48    49    46    42    44    43
   110    79    54    47    48    45
   190   192   190   153    99    54
   150   166   189   203   183   170
   131   140   145   161   165   178

</pre><img vspace="5" hspace="5" src="index_02.png"> <p>Les valeurs de l'images extraite sont: \[ \left[ \begin{array}{ccc}   43    &amp;43   &amp; 43  &amp;  41  &amp;  40 &amp;   39 \\   48    &amp;49
              &amp; 46  &amp;  42 &amp;   44  &amp;  43\\   110   &amp; 79  &amp;  54 &amp;   47  &amp;  48 &amp;   45\\   190   &amp;192  &amp; 190  &amp; 153  &amp;  99 &amp;   54\\   150
              &amp;166  &amp; 189 &amp;  203  &amp; 183 &amp;  170\\   131   &amp;140  &amp; 145 &amp;  161  &amp; 165 &amp;  178\\ \end{array} \right] \]
         </p>
         <h2>Stocker une image<a name="17"></a></h2>
         <p>Stocker de grandes images sur le <a href="http://fr.wikipedia.org/wiki/Disque_dur">disque dur</a> d'un ordinateur prend beaucoup de place. Les nombres entiers sont stock&eacute;s en <a href="http://fr.wikipedia.org/wiki/Syst%C3%A8me_binaire">&eacute;criture binaire</a>, c'est-&agrave;-dire sous la forme d'une succession de 0 et de 1. Chaque 0 et chaque 1 se stocke sur une unit&eacute; &eacute;l&eacute;mentaire de stockage,
            appel&eacute;e <a href="http://fr.wikipedia.org/wiki/Bit">bit</a>.
         </p>
         <p>Pour obtenir l'&eacute;criture binaire d'un pixel ayant comme valeur 179, il faut d&eacute;composer cette valeur comme somme de puissances
            de deux. On obtient ainsi \[ 179=2^7+2^5+2^4+2+1, \] o&ugrave; l'on a pris soin d'ordonner les puissances de deux par ordre d&eacute;croissant.
            Afin de faire mieux appara&icirc;tre l'&eacute;criture binaire, on ajoute "\(1 \times\)" devant chaque puissance qui appara&icirc;t dans l'&eacute;criture,
            et "\(0\times\)" devant les puissances qui n'apparaissent pas \[ 179=1 \times 2^7 + 0 \times 26 + 1 \times 2^5 + 1 \times
            24 +   0 \times 2^3 + 0 \times 22 + 1 \times 2^1 + 1 \times 2^0. \]
         </p>
         <p>Avec une telle &eacute;criture, la valeur de chaque pixel, qui est un nombre entre 0 et 255, n&eacute;cessite \[ \log_2(256) = 8 \text{
            bits}. \] La fonction \(\log_2\) est le logarithme en base 2, et ce calcul exprime le fait que \[ 256=2^8 = 2 \times 2 \times
            2 \times 2 \times 2 \times 2 \times 2 \times 2.  \] L'&eacute;criture binaire de la valeur 179 du pixel est ainsi \((1,0,1,1,0,0,1,1)\),
            o&ugrave; chaque 1 et chaque 0 correspond au facteur multiplicatif qui appara&icirc;t devant chaque puissance.
         </p>
         <p>On peut &eacute;crire toute valeur entre 0 et 255 de cet mani&egrave;re, ce qui n&eacute;cessite d'utilisation de 8 bits. Il y a en effet 256 valeurs
            possibles, et \(256=2^8\). Pour stocker l'image compl&egrave;te, on a donc besoin de \[ n \times p \times 8 \text{ bits}. \]
         </p>
         <p>Pour stocker l'image compl&egrave;te, on a donc besoin de \[ n \times p \times 8  \text{ bits}. \] Pour l'image montr&eacute;e aux figure
            pr&eacute;c&eacute;dentes, on a ainsi besoin de \[ 256 \times 256 \times 8 = 524288 \text{ bits}. \]
         </p>
         <p>Pour l'image montr&eacute;e &agrave; la premi&egrave;re figure, on a ainsi besoin de \[ 240 \times 240 \times 8 = 460800 \text{ bits.} \] On utilise
            le plus souvent <a href="http://fr.wikipedia.org/wiki/Octet">l'octet</a> (8 bits) comme unit&eacute;, de sorte que cette image n&eacute;cessite 57,6ko (kilo octets).
         </p>
         <h2>La r&eacute;solution d'une image<a name="23"></a></h2>
         <p>Afin de r&eacute;duire la place de stockage d'une image, on peut r&eacute;duire sa <a href="http://fr.wikipedia.org/wiki/R%C3%A9solution_(imagerie_num%C3%A9rique)">r&eacute;solution</a>, c'est-&agrave;-dire diminuer le nombre de pixels.
         </p>
         <p>La fa&ccedil;on la plus simple d'effectuer cette r&eacute;duction consiste &agrave; supprimer des lignes et des colonnes dans l'image de d&eacute;part.</p>
         <p>La figure suivante montre ce que l'on obtient si l'on retient une ligne sur 4 et une colonne sur 4.</p><pre class="codeinput">sub = @(f,k)f(1:k:end,1:k:end);

clf;
imageplot(sub(f,4));
</pre><img vspace="5" hspace="5" src="index_03.png"> <p>On a ainsi divis&eacute; par \(4 \times 4 = 16\) le nombre de pixels de l'image, et donc &eacute;galement r&eacute;duit par 16 le nombre de bit
            n&eacute;cessaire pour stocker l'image sur un disque dur.
         </p>
         <p>La figure suivante montre les r&eacute;sultats obtenus en enlevant de plus en plus de lignes et de colonnes. Bien entendu, la qualit&eacute;
            de l'image se d&eacute;grade vite.
         </p><pre class="codeinput">klist = [2 4 8 16];
clf;
<span class="keyword">for</span> i=1:length(klist)
    k = klist(i);
    imageplot(clamp(sub(f,k)), [<span class="string">'1 ligne/colonne sur '</span> num2str(k)], 2, 2, i);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_04.png"> <h2>Quantifier une image<a name="28"></a></h2>
         <p>Une autre fa&ccedil;on de r&eacute;duire la place m&eacute;moire n&eacute;cessaire pour le stockage consiste &agrave; utiliser moins de nombres entirers pour
            chaque valeur.
         </p>
         <p>On peut par exemple utiliser uniquement des nombres entier entre 0 et 3, ce qui donnera une image avec uniquement 4 niveau
            de gris.
         </p>
         <p>On peut effectuer une conversion de l'image d'origine vers une image avec 3 niveau de valeurs en effectuant les remplacements:</p>
         <p>- les valeurs dans \(0,1,\ldots,63\) sont remplac&eacute;es par la valeur 0,</p>
         <p>- les valeurs dans \(64,1,\ldots,127\) sont remplac&eacute;es par la valeur 1,</p>
         <p>- les valeurs dans \(128,1,\ldots,191\) sont remplac&eacute;es par la valeur 2,</p>
         <p>- les valeurs dans \(192,\ldots,255\) sont remplac&eacute;es par la valeur 3.</p>
         <p>Une telle op&eacute;ration se nomme <a href="http://fr.wikipedia.org/wiki/Quantification_(signal)">quantification</a>.
         </p>
         <p>La figure suivante montre l'image r&eacute;sultante avec 4 niveaux de couleurs. Les 4 valeurs sont affich&eacute;es en utilisant 4 niveaux
            de gris allant du noir au blanc.
         </p><pre class="codeinput">quant = @(f,q)(round(q*rescale(f,1e-3,1-1e-3)-1/2)+1/2)/q;
clf;
imageplot(quant(f,4), <span class="string">'4 niveaux de gris'</span>);
</pre><img vspace="5" hspace="5" src="index_05.png"> <p>Nous avons d&eacute;j&agrave; vu que l'on pouvait repr&eacute;senter toute valeur entre 0 et 255 &agrave; l'aide de 8 bits en utilisant l'&eacute;criture binaire.
            De fa&ccedil;on similaire, on v&eacute;rifie que toute valeur entre 0 et 3 peut se repr&eacute;senter &agrave; l'aide de 2 bits. On obtient ainsi une
            r&eacute;duction d'un facteur 8/2=4 de la place <a href="http://fr.wikipedia.org/wiki/M%C3%A9moire_(informatique)">m&eacute;moire</a> n&eacute;cessaire pour le stockage de l'image sur un disque dur.
         </p>
         <p>La figure suivante montre les r&eacute;sultats obtenus en utilisant de moins en moins de niveaux de gris.</p><pre class="codeinput">qlist = [16, 4, 3, 2];
clf;
<span class="keyword">for</span> i=1:length(qlist)
    q = qlist(i);
    f1 = quant(f,q); f1(1)=0; f1(2)=1;
    imageplot(f1, [num2str(q) <span class="string">' niveaux de gris'</span> ], 2, 2, i);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_06.png"> <p>Tout comme pour la r&eacute;duction du nombre de pixels, la r&eacute;duction du nombre de niveaux de gris influe beaucoup sur la qualit&eacute;
            de l'image. Afin de r&eacute;duire au maximum la taille d'une image sans modifier sa qualit&eacute;, on utilise des m&eacute;thodes plus complexes
            de <a href="http://fr.wikipedia.org/wiki/Compression_d%27image">compression d'image</a>. La m&eacute;thode la plus efficace s'appelle <a href="http://fr.wikipedia.org/wiki/Jpeg_2000">JPEG-2000</a>. Elle utilise la th&eacute;orie des <a href="http://fr.wikipedia.org/wiki/Ondelettes">ondelettes</a>. Pour en savoir plus &agrave; ce sujet, vous pouvez consuler cet <a href="http://images.math.cnrs.fr/Compression-d-image.html">article d'Erwan Le Pennec</a>.
         </p>
         <h2>Enlever le bruit par moyennes locales<a name="37"></a></h2>
         <p>Les images sont parfois de mauvaise qualit&eacute;. Un exemple typique de d&eacute;faut est le <a href="http://fr.wikipedia.org/wiki/Bruit_num%C3%A9rique">bruit</a> qui apparait quand une photo est <a href="http://fr.wikipedia.org/wiki/Exposition_(photographie)">sous-expos&eacute;e</a>, c'est-&agrave;-dire qu'il n'y a pas assez de luminosit&eacute;. Ce bruit se manifeste par de petites flucturation <a href="http://fr.wikipedia.org/wiki/Suite_al%C3%A9atoire">al&eacute;atoires</a> des niveaux de gris. La figure ci-dessous montre une image bruit&eacute;e.
         </p><pre class="codeinput">name = <span class="string">'boat'</span>;
f = rescale(load_image(name, n));
sigma = .08;
f = f + randn(n)*sigma;
clf;
imageplot(f);
</pre><img vspace="5" hspace="5" src="index_07.png"> <p>Afin d'enlever le bruit dans les images, il convient de faire subir une modification aux valeurs de pixels. L'op&eacute;ration la
            plus simple consiste &agrave; remplacer la valeur \(a\) de chaque pixel par la <a href="http://fr.wikipedia.org/wiki/Moyenne">moyenne</a> de \(a\) et des 8 valeurs \(b,c,d,e,f,g,h,i\) des 8 pixels voisins de a.
         </p>
         <p>Les valeurs des pixels sont positionn&eacute;es comme suit : \[ \left[ \begin{array}{ccc}       g &amp; c &amp; h \\       b &amp; a &amp; d \\ 
                 f &amp; e &amp; i \end{array} \right]   = \left[ \begin{array}{ccc}       79 &amp; 54 &amp; 47 \\       192 &amp; 190 &amp; 153 \\       166
            &amp; 189 &amp; 203 \end{array} \right] \]
         </p>
         <p>On obtient ainsi une image modifi&eacute;e en rempla&ccedil;ant a par \[ \frac{a+b+c+d+e+f+g+h+i}{9} \] puisque l'on fait la moyenne de
            9 valeurs. Dans notre exemple, cette moyenne vaut \[ \frac{190+192+79+54+47+153+203+189+166}{9} \approx 141,4. \] En effectuant
            cette op&eacute;ration pour chaque pixel, on supprime une partie du bruit, car ce bruit est constitu&eacute; de fluctuations al&eacute;atoires,
            qui sont diminu&eacute;es par un calcul de moyennes. La figure ci-dessous montre l'effet d'un tel calcul.
         </p>
         <p>La figure ci-dessous montre l'effet d'un tel moyennage.</p><pre class="codeinput">filt_moy = @(f,k)perform_convolution(f,ones(2*k+1)/(2*k+1)^2,<span class="string">'sym'</span>);
clf;
imageplot(clamp(f), <span class="string">'Image bruit&eacute;e'</span>, 1, 2, 1);
imageplot(clamp(filt_moy(f,1)), <span class="string">'Image moyenn&eacute;e'</span>, 1, 2, 2);
</pre><img vspace="5" hspace="5" src="index_08.png"> <p>Tout le bruit n'a pas &eacute;t&eacute; enlev&eacute; par cette op&eacute;ration. Afin d'enlever plus de bruit, on peut moyenner plus de valeurs autour
            de chaque pixel. La figure suivante montre le r&eacute;sultat obtenu en moyennant de plus en plus de valeurs.
         </p><pre class="codeinput">klist = [1 2 3 4];
clf;
<span class="keyword">for</span> i=1:length(klist)
    k = klist(i);
    f1 = filt_moy(f,k);
    imageplot(clamp(f1), [<span class="string">'Moyenne de '</span> num2str((2*k+1)^2) <span class="string">' pixels'</span>], 2, 2, i);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_09.png"> <p>Le moyennage des pixels est tr&egrave;s efficace pour enlever le bruit dans les images, malheureusement il d&eacute;truit &eacute;galement une
            grande partie de l'information de l'image. on peut en effet s'appercevoir que les images obtenues par moyennage sont <a href="http://fr.wikipedia.org/wiki/Flou,_nettet%C3%A9_et_contraste">floues</a>. Ceci est en particulier visible pr&egrave;s des contours, qui ne sont pas nets.
         </p>
         <h2>Enlever le bruit par m&eacute;diane<a name="44"></a></h2>
         <p>Afin de r&eacute;duire ce flou, il faut remplacer le moyennage par une op&eacute;ration un peu plus complexe, que l'on nomme <a href="http://fr.wikipedia.org/wiki/M%C3%A9diane">mediane</a>.
         </p>
         <p>Etant donn&eacute; la valeur \(a\) d'un pixel, et les valeurs \(b,c,d,e,f,g,h,i\), on commence par les classer par <a href="http://fr.wikipedia.org/wiki/Ordre_croissant">ordre croissant</a>.
         </p>
         <p>Dans l'exemple du voisinage de 9 pixels utilis&eacute; &agrave; la section pr&eacute;c&eacute;dente, on obtient les 9 valeurs class&eacute;es \[ 47,54,79,153,166,189,190,192,203.
            \] La m&eacute;diane des neuf valeurs \(a,b,c,d,e,f,g,h,i\) est la \(5^\text{e}\) valeur de ce classement (c'est-&agrave;-dire la valeur
            centrale de ce classement).
         </p>
         <p>Dans notre cas, la m&eacute;diane est donc 166. Notez que ce nombre est en g&eacute;n&eacute;ral diff&eacute;rent de la moyenne, qui vaut, pour notre
            exemple 141,4.
         </p>
         <p>La figure ci-dessous compare le d&eacute;bruitage obtenu en effectuant la moyenne et la m&eacute;diane de 9 pixels voisins.</p><pre class="codeinput">filt_med = @(f,k)perform_median_filtering(f,k);
clf;
imageplot(clamp(filt_moy(f,1)), <span class="string">'Moyenne de 9 nombres'</span>, 1, 2, 1);
imageplot(clamp(filt_med(f,1)), <span class="string">'M&eacute;diane de 9 nombres'</span>, 1, 2, 2);
</pre><img vspace="5" hspace="5" src="index_10.png"> <p>Afin d'enlever plus de bruit, il suffit de calculer la m&eacute;diane sur un nombre plus grand de pixels voisins, comme montr&eacute; &agrave;
            la figure suivante.
         </p><pre class="codeinput">klist = [1 2 3 4];
clf;
<span class="keyword">for</span> i=1:length(klist)
    k = klist(i);
    f1 = filt_med(f,k);
    imageplot(clamp(f1), [<span class="string">'M&eacute;diane de '</span> num2str((2*k+1)^2) <span class="string">' pixels'</span>], 2, 2, i);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_11.png"> <p>On constate que cette m&eacute;thode est plus performante que le calcul de moyennes, car les images r&eacute;sultantes sont moins floues.
            Cependant, tout comme avec le calcul de moyennes, si l'on prend des voisinages trop grands, on perd aussi de l'information
            de l'image, en particulier les bords des objets sont d&eacute;grad&eacute;s.
         </p>
         <h2>D&eacute;tecter les bords des objets<a name="51"></a></h2>
         <p>Affin de localiser des objets dans les images, il est n&eacute;cessaire de d&eacute;tecter les <a href="http://fr.wikipedia.org/wiki/D%C3%A9tection_de_contours">bords</a> de ces objets. Ces bords correspondent &agrave; des zones de l'image o&ugrave; les valeurs des pixels changent rapidement. C'est le cas
            par exemple lorsque l'on passe de la coque du bateau (qui est sombre, donc avec des valeurs petites) &agrave; la mer (qui est claire,
            donc avec des valeurs grandes).
         </p>
         <p>Afin de quantifier combien un pixel avec une valeur \(a\) est un bord, on prend en compte les valeurs \(b,c,d,e\) de ses quatre
            voisins (deux horizontallement et deux verticalements). Dans le cas consid&eacute;r&eacute; pr&eacute;c&eacute;demment, on obtient : \[ \left[ \begin{array}{ccc}
                   &amp; c &amp;  \\       b &amp; a &amp; d \\        &amp; e &amp; \end{array} \right]   = \left[ \begin{array}{ccc}        &amp; 54 &amp;  \\     
             192 &amp; 190 &amp; 153 \\        &amp; 189 &amp; \end{array} \right] \]
         </p>
         <p>Notons que l'on utilise ici seulement 4 voisins, ce qui est diff&eacute;rent du calcul de moyennes et de m&eacute;dianes o&ugrave; l'on utilisait
            8 voisins. Ceci est important afin de d&eacute;tecter aussi pr&eacute;cis&eacute;ment que possible les bords des objets.
         </p>
         <p>On calcule une valeur \(\ell\) suivant la formule \[ \ell = \sqrt{ (b-d)^2 + (c-e)^2 }.  \] Dans notre exemple, on obtient
            donc \[ \ell= \sqrt{&nbsp;(192 - 153)^2 + (189 - 54)^2 } = \sqrt{19746} \approx 140,5. \]
         </p>
         <p>On peut remarquer que si \(\ell=0\), alors on a \(b=c\) et \(d=e\). Au contraire, si \(\ell\) est grand, ceci signifie que
            les pixels voisins ont des valeurs tr&egrave;s diff&eacute;rentes, le pixel consid&eacute;r&eacute; est donc probablement sur le bord d'un objet.
         </p>
         <p>La figure suivante montre l'image obtenue en calculant la valeur \(\ell\) associ&eacute;e &agrave; chaque pixel. On a affich&eacute; ces valeurs
            avec du noir quand \(\ell=0\),  du blanc quand \(\ell\) est grand, et on a utilis&eacute; des niveaux de gris interm&eacute;diaire pour
            les valeurs entre 0 et 1.
         </p><pre class="codeinput">n = 256;
name = <span class="string">'hibiscus'</span>;
f = load_image(name, n);
f = rescale(sum(f,3));

s1 = [1 1:n-1]; s2 = [2:n n];
edge = @(f)sqrt( ( f(s1,:) - f(s2,:) ).^2 + ( f(:,s1) - f(:,s2) ).^2 );

clf;
imageplot(f, <span class="string">'Image'</span>, 1,2,1);
imageplot(edge(f), <span class="string">'Carte de l'</span>, 1,2,2);
</pre><img vspace="5" hspace="5" src="index_12.png"> <p>On peut voir que dans l'image de droite, les contours des objets ressortent en blanc, car ils correspondent aux grandes valeurs
            de \(\ell\).
         </p>
         <h2>Les images couleurs<a name="58"></a></h2>
         <p>Une <a href="http://fr.wikipedia.org/wiki/Couleur">image couleur</a> est en r&eacute;alit&eacute; compos&eacute;e de trois images ind&eacute;pendantes, afin de repr&eacute;senter le <a href="http://fr.wikipedia.org/wiki/Rouge_vert_bleu">rouge, le vert, et le bleu</a>. Chacune de ces trois image s'appelle un <a href="http://fr.wikipedia.org/wiki/Codage_informatique_des_couleurs">canal</a>. Cette repr&eacute;sentation en rouge, vert et bleu mime le fonctionnement du syst&egrave;me visuel humain.
         </p>
         <p>La figure suivante montre une image couleur, qui est d&eacute;compos&eacute;e en ses trois canaux constitutifs.</p><pre class="codeinput">name = <span class="string">'hibiscus'</span>;
f = rescale( load_image(name,n) );


f1 = cat(3, f(:,:,1), zeros(n), zeros(n));
f2 = cat(3, zeros(n), f(:,:,2), zeros(n));
f3 = cat(3, zeros(n), zeros(n), f(:,:,3));

clf;
imageplot({f f1 f2 f3}, <span class="keyword">...</span>
        { <span class="string">'Image couleur'</span> <span class="string">'Canal rouge'</span> <span class="string">'Canal vert'</span> <span class="string">'Canal bleu'</span>}, 2, 2);
</pre><img vspace="5" hspace="5" src="index_13.png"> <p>Chaque pixel de l'image couleur contient ainsi trois nombres \( (r,v,b) \), chacun &eacute;tant un nombre entier entre 0 et 255.
            Si le pixel est &eacute;gal &agrave; \((r,v,b)=(255,0,0)\), il ne contient que de l'information rouge, et est affich&eacute; comme du rouge. De
            fa&ccedil;on similaire, les pixels valant \((0,255,0)\) et \((0,0,255)\) sont respectivement affich&eacute;s vert et bleu.
         </p>
         <p>On peut afficher &agrave; l'&eacute;cran une image couleur &agrave; partir de ses trois canaux \((r,v,b)\) en utilisant les r&egrave;gles de la <a href="http://fr.wikipedia.org/wiki/Synth%C3%A8se_additive">synth&egrave;se additive des couleurs</a>. La figure suivante montre les r&egrave;gles de composition cette synth&egrave;se additive des couleurs. Par exemple un pixel avec les
            valeurs \((r,v,b)=(255,0,255)\) est un m&eacute;lange de rouge et de vert, il est donc affich&eacute; comme du jaune.
         </p>
         <p>On peut calculer une image en niveau de gris &agrave; partir d'une image couleur en moyennant les trois cannaux. On calcule donc
            une valeur \[ a = \frac{r+v+b}{3} \] qui s'appelle la <a href="http://fr.wikipedia.org/wiki/Luminance">luminance</a> de la couleur.
         </p>
         <p>La figure suivante montre le passage d'une image couleur &agrave; une image de luminance en niveau de gris.</p><pre class="codeinput">clf;
imageplot({f sum(f,3)}, {<span class="string">'Couleur'</span> <span class="string">'Luminance'</span>});
</pre><img vspace="5" hspace="5" src="index_14.png"> <p>Une autre repr&eacute;sentation courante pour les images couleurs utilise comme couleurs de base le cyan, le magenta et le jaune.
            On calcule les trois nombres \((c,m,j)\) correspondant &agrave; chacun de ces trois canaux &agrave; partir des canaux rouge, vert et bleu
            \((r,v,b)\) comme suit \[ c=255-r, \quad m=255-v, \quad j=255-b. \] Par exemple, un pixel de bleu pur \((r,v,b)=(0,0,255)\)
            va devenir \( (c,m,j)=(255,255,0) \). La figure suivante montre les trois canaux \((c,m,j)\) d'une image couleur.
         </p><pre class="codeinput">g = 1-f;
f1 = cat(3, f(:,:,1),     f(:,:,2)*0+1, f(:,:,3)*0+1);
f2 = cat(3, f(:,:,1)*0+1, f(:,:,2)    , f(:,:,3)*0+1);
f3 = cat(3, f(:,:,1)*0+1, f(:,:,2)*0+1, f(:,:,3));


clf;
imageplot({f f1 f2 f3}, <span class="keyword">...</span>
        { <span class="string">'Image couleur'</span> <span class="string">'Canal cyan'</span> <span class="string">'Canal magenta'</span> <span class="string">'Canal jaune'</span>}, 2, 2);
</pre><img vspace="5" hspace="5" src="index_15.png"> <p>Afin d'afficher une image couleur &agrave; l'&eacute;cran &agrave; partir des trois canaux \((c,m,j)\), on doit utiliser la synth&egrave;se soustractive
            des couleurs. La figure suivante montre les r&egrave;gles de composition cette synth&egrave;se soustractive. Notons que ces r&egrave;gles sont
            celles que l'on utilise en peinture, lorsque l'on m&eacute;lange des pigments color&eacute;s. Le cyan, le magenta et le jaune sont appel&eacute;s
            couleurs primaires.
         </p>
         <p>On peut donc stocker sur un disque dur une image couleur en stockant les trois canaux, correspondant aux valeurs \((r,g,b)\)
            ou \((c,m,j)\). On peut modifier les images couleur tout comme les images en niveaux de gris. La fa&ccedil;on la plus simple de proc&eacute;der
            consiste &agrave; appliquer la modification &agrave; chacun des canaux.
         </p>
         <h2>Changer le contraste d'une image<a name="67"></a></h2>
         <p>Il est possible de faire subir diff&eacute;rentes modifications &agrave; l'image afin de changer son <a href="http://fr.wikipedia.org/wiki/Contraste">contraste</a>.
         </p><pre class="codeinput">name = <span class="string">'hibiscus'</span>;
f = rescale( load_image(name,n) );
f = rescale(sum(f,3));
</pre><p>Un exemple simple consiste &agrave; remplacer chaque valeur \(a\) d'un pixel d'une image par \(255-a\) ce qui correspond &agrave; la couleur
            oppos&eacute;e. Le blanc devient noir et vice-et-versa, ce qui donne un effet similaire &agrave; celui des <a href="http://fr.wikipedia.org/wiki/Film_n%C3%A9gatif">n&eacute;gatifs</a> <a href="http://fr.wikipedia.org/wiki/Argentique">d'appareils photos argentiques</a>.
         </p><pre class="codeinput">clf;
imageplot(-f);
</pre><img vspace="5" hspace="5" src="index_16.png"> <p>Sans aller jusqu'&agrave; des modifications aussi extr&ecirc;mes, on peut assombrir une image en rempl&ccedil;ant la valeur \(a\) de chaque pixel
            par son <a href="http://fr.wikipedia.org/wiki/Carr%C3%A9_(alg%C3%A8bre)">carr&eacute;</a> \(a^2 = a \times a\).
         </p>
         <p>Ce faisant, les valeurs r&eacute;sultantes ne sont plus dans \(0,\ldots,255\) mais dans \(0,\ldots,255^2=65025\). Afin d'afficher
            l'image &agrave; l'&eacute;cran on va donc utiliser des niveaux de gris allant du noir pour 0 au blanc pour 65025.
         </p><pre class="codeinput">clf;
imageplot(f.^2, <span class="string">'Carr&eacute;'</span>);
</pre><img vspace="5" hspace="5" src="index_17.png"> <p>Afin d'&eacute;claircir l'image, on peut remplacer chaque valeur \(a\) par sa <i>racine carr&eacute;e</i> \(b = \sqrt{a}\). Cette valeur \(b\) est un nombre, qui n'est plus n&eacute;cessairement entier, qui satisfait \(b \times b = a\).
         </p>
         <p>La figure suivante montre l'&eacute;claircissement obtenu. Les valeurs de l'image &eacute;claircie sont dant \(0,\ldots,\sqrt{255} \approx
            16\), et on utilise donc des niveaux de gris allant du noir (pour 0) au blanc (pour 16).
         </p><pre class="codeinput">clf;
imageplot(sqrt(f), <span class="string">'Remplacement de a par sqrt(a)'</span>);
</pre><img vspace="5" hspace="5" src="index_18.png"> <p>On pourra noter que l'on a \[ \sqrt{a} \times \sqrt{a} = a \quad\text{et}\quad \sqrt{a \times a}=a \] de sorte que si l'on
            r&eacute;alise un &eacute;clairsissement suivit d'un assombrissement (ou dans le sens inverse) on retrouve l'image d'origine. Ces deux op&eacute;rations
            sont <a href="http://fr.wikipedia.org/wiki/Inverse">inverses</a> l'une de l'autre.
         </p>
         <p>On peut &eacute;galement changer le contraste d'une image couleur en changeant sa composante de luminance.</p><pre class="codeinput">name = <span class="string">'hibiscus'</span>;
f = rescale( load_image(name,n) );

m = @(f)repmat(mean(f,3), [1 1 3]);
contrast = @(f,gamma)clamp(m(f).^gamma + f-m(f));

gamma_list = [.5 .75 1 1.5 2 3];
clf;
<span class="keyword">for</span> i=1:length(gamma_list)
    subplot(2,3,i);
    image(contrast(f,gamma_list(i))); axis <span class="string">image</span>; axis <span class="string">off</span>;
    title([<span class="string">'\gamma='</span> num2str(gamma_list(i))]);
    colormap <span class="string">jet(256)</span>;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_19.png"> <h2>Transformations g&eacute;om&eacute;triques<a name="75"></a></h2>
         <p>Une image est un tableau de nombres, avec \(n\) lignes et \(p\) colonnes. Il est donc facile d'effectuer certaines <a href="http://fr.wikipedia.org/wiki/Transformation_g%C3%A9om%C3%A9trique">transformations g&eacute;om&eacute;triques</a> sur l'image.
         </p>
         <p>Les valeurs des pixels qui composent ce tableau (not&eacute; \(A\)) peuvent &ecirc;tre repr&eacute;sent&eacute;es sous la forme \( A = ( a_{i,j} )_{i,j}
            \) ou l'index \(i\) d&eacute;crit l'ensemble des nombres \( \{1,\ldots,n\} \) (les entiers entre 1 et n) et l'index \(j\) les nombres
            \( \{1,\ldots,p\} \). One dit que \(a_{i,j}\) est la valeur du pixel &agrave; la position \((i,j)\).
         </p>
         <p>Le tableau de pixels ainsi index&eacute; peut se repr&eacute;senter sous la fa&ccedil;on suivante \[ A = \begin{pmatrix} a_{1,1} &amp;           &amp;
                      &amp;   &amp; a_{1,p}\\        &amp;           &amp;  \vdots   &amp;   &amp;  \\ 	   &amp;           &amp; a_{i-1,j} &amp;   &amp; \\ \ldots &amp; a_{i,j-1}
            &amp; a_{i,j}   &amp; a_{i,j+1} &amp; \ldots\\ 	   &amp;           &amp; a_{i+1,j} &amp;   &amp; \\        &amp;           &amp;  \vdots   &amp;   &amp;  \\ a_{n,1} &amp;
                      &amp;           &amp;   &amp; a_{n,p}\\ \end{pmatrix} \] ce qui montre que le pixel en haut &agrave; gauche de l'image correspond &agrave;
            la valeur \(a_{1,1}\). Ceci correspond &agrave; la repr&eacute;sentation de l'image sous forme d'une <a href="http://fr.wikipedia.org/wiki/Matrice_(math%C3%A9matiques)">matrice</a>.
         </p>
         <p>Si l'on &eacute;change le r&ocirc;le des lignes et des colonnes, on d&eacute;finit un autre tableau \(B\) avec \(p\) lignes et \(n\) colonnes.
            La formule qui d&eacute;finit le tableau \(B = ( b_{j,i} )_{i,j}\) est \[ b_{j,i} = a_{i,j}. \] Ceci correspond &agrave; la <a href="http://fr.wikipedia.org/wiki/Matrice_transpos%C3%A9e">transposition</a> de la matrice correspondant &agrave; l'image.
         </p>
         <p>Pour une image couleur, on effectue cette modification sur chacune de ses trois composantes couleur R, V et B.</p>
         <p>La figure suivante montre l'image correspondant au tableau \(A\) et l'image correspondant au tableau \(B\). On peut constater
            que la modification correspond &agrave; faire sur l'image une <a href="http://fr.wikipedia.org/wiki/Sym%C3%A9trie_(transformation_g%C3%A9om%C3%A9trique)">sym&eacute;trie</a> par rapport &agrave; la <a href="http://fr.wikipedia.org/wiki/Diagonale">diagonale</a> qui joint le coin haut/gauche au coin bas/droite.
         </p><pre class="codeinput">A = rescale( load_image(<span class="string">'flowers'</span>,512) );
B = permute(A, [2 1 3]);
clf;
imageplot({A B}, {<span class="string">'Image A'</span> <span class="string">'Image B'</span>}, 1,2,1);
</pre><img vspace="5" hspace="5" src="index_20.png"> <p>On peut &eacute;galement effectuer une <a href="http://fr.wikipedia.org/wiki/Rotation">rotation</a> d'un quart de tour dans le sens d'une montre &agrave; l'image. Ceci est effectu&eacute; en d&eacute;finissant une image \(C = (c_{i,j})_{j,i}\)
            de \(p\) lignes et \(n\) colonnes dont le tableau de nombre est calcul&eacute; par \[ c_{j,i} =  a_{n-i+1,j}.\]
         </p><pre class="codeinput">C = A;
C = C(end:-1:1,:,:); C = permute(C, [2 1 3]);
clf;
imageplot({A C}, {<span class="string">'Image A'</span> <span class="string">'Image C'</span>}, 1,2,1);
</pre><img vspace="5" hspace="5" src="index_21.png"> <h2>Fondu entres deux images<a name="82"></a></h2>
         <p>On souhaite effectuer une <a href="http://fr.wikipedia.org/wiki/Fondu">transition entre deux images</a> \(A\) et \(B\) de m&ecirc;me taille. On suppose donc que chaque image a le m&ecirc;me nombre \(n\) de lignes et le m&ecirc;me nombre \(p\)
            de colonnes.
         </p>
         <p>La figure ci-dessous montre les deux images entre lesquelles on souhaite calculer une transition.</p><pre class="codeinput">A = rescale( load_image(<span class="string">'flowers'</span>,512) );
B = rescale( load_image(<span class="string">'hibiscus'</span>,512) );
clf;
imageplot({A B}, {<span class="string">'Image A'</span>, <span class="string">'Image B'</span>});
</pre><img vspace="5" hspace="5" src="index_22.png"> <p>One note \(A = (a_{i,j})_{i,j}\) les pixels de l'image \(A\) et \(B = (b_{i,j})_{i,j}\) les pixels de l'image \(B\).</p>
         <p>Pour une valeur \(t\) fix&eacute;e entre \(0\) et \(1\), on d&eacute;finit l'image \(C = (c_{i,j})_{i,j}\) comme \[ c_{i,j}  = (1-t) a_{i,j}
            + t b_{i,j}.\] Il s'agit de la formule d'une <a href="http://fr.wikipedia.org/wiki/Interpolation_lin%C3%A9aire">interpolation lin&eacute;aire</a> entre les deux images.
         </p>
         <p>Si l'image est une image couleur, on applique cette formule &agrave; chacun des canaux R, V et B.</p>
         <p>On peut constater que pour \(t=0\), l'image \(C\) est &eacute;gale &agrave; l'image \(A\). Pour \(t=1\), l'image \(c\) est &eacute;gale &agrave; l'image
            \(B\). Lorsque la valeur \(t\) progresse de 0 &agrave; 1, on obtient ainsi un effet de fondu, puisque l'image, qui au d&eacute;part est
            proche de l'image \(A\) ressemble de plus en plus &agrave; l'image \(B\).
         </p>
         <p>La figure suivante montre 5 valeurs de \(t\) r&eacute;parties entre 0 et 1.</p><pre class="codeinput">p = 6;
t = linspace(0,1,p);
clf;
<span class="keyword">for</span> i=1:p
    imageplot(t(i)*A+(1-t(i))*B, [<span class="string">'t='</span> num2str(t(i), 2)], 2,p/2,i);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="index_23.png"> <h2>Conclusion<a name="89"></a></h2>
         <p>Cet article n'a fait qu'effleurer l'immense liste des traitements que l'on peut faire subir &agrave; une image. Le traitement math&eacute;matique
            des images est un domaine tr&egrave;s actif, o&ugrave; les avanc&eacute;es th&eacute;oriques se concr&eacute;tisent sous la forme d'algorithmes rapides de calcul
            qui ont des applications importantes pour la manipulation des contenus num&eacute;riques.
         </p>
         <p>Les personnes int&eacute;ress&eacute;es pourront consulter le site web <a href="http://www.numerical-tours.com/">A Numerical Tour of Signal Processing</a> pour de nombreux exemples de traitements d'images. On y trouve &eacute;galement des liens vers d'autres ressources disponibles en
            ligne.
         </p>
         <h2>Glossaire<a name="91"></a></h2>
         <p>- <b>Al&eacute;atoire</b> : valeur impr&eacute;visible souvent due au hazard, comme par exemple le bruit qui perturbe les images de mauvaises qualit&eacute;s.
         </p>
         <p>- <b>Bit</b> : unit&eacute; &eacute;lementaire de stockage de l'information sous forme de 0 et de 1 dans un ordinateur.
         </p>
         <p>- <b>Canal</b> : une des trois images &eacute;l&eacute;mentaires qui composent une image couleur.
         </p>
         <p>- <b>Bords</b> : zone d'une image o&ugrave; les valeurs des pixels varient beaucoup, qui correspond aux contours des objets qui forment l'image.
         </p>
         <p>- <b>Bruit</b> : petites perturbations qui d&eacute;gradent la qualit&eacute; d'une image.
         </p>
         <p>- <b>Carr&eacute;</b> : le carr&eacute; \(b\) d'une valeur \(a\) est \(a \times a\). Il est not&eacute; \(a^2\).
         </p>
         <p>- <b>Contraste</b> : quantit&eacute; informelle qui indique la diff&eacute;rence entre les zones claires et les zones sombres d'une image.
         </p>
         <p>- <b>Compression d'image</b> : m&eacute;thode permettant de r&eacute;duire la place m&eacute;moire n&eacute;cessaire au stockage sur le disque dur d'une image.
         </p>
         <p>- <b>Ecriture binaire</b> : &eacute;criture de valeurs num&eacute;riques &agrave; l'aide uniquement de 0 et de 1.
         </p>
         <p>- <b>Flou</b> : d&eacute;gradation d'une image qui rend les contours des objets peu net, et donc difficile &agrave; localiser pr&eacute;cis&eacute;ment.
         </p>
         <p>- <b>Fondu</b> : interpolation lin&eacute;aire entre deux images.
         </p>
         <p>- <b>Image couleur</b> : ensemble de trois images en niveau de gris, qui peut &ecirc;tre affich&eacute; &agrave; l'&eacute;cran en couleur.
         </p>
         <p>- <b>Image num&eacute;rique</b> : tableau de valeurs que l'on peut afficher &agrave; l'&eacute;cran en assignant un niveau de gris &agrave; chaque valeur.
         </p>
         <p>- <b>Inverse</b> : op&eacute;ration ramenant une image dans son &eacute;tat d'origine.
         </p>
         <p>- <b>JPEG-2000</b> : m&eacute;thode r&eacute;cente de compression d'images qui utilise une transformation en ondelettes.
         </p>
         <p>- <b>Luminance</b> : moyenne des diff&eacute;rents canaux d'une image, qui indique la puissance lumineuse du pixel.
         </p>
         <p>- <b>Matrice</b> : tableau de valeurs, repr&eacute;sent&eacute; sous la forme \((a_{i,j})_{i,j}\).
         </p>
         <p>- <b>M&eacute;diane</b> : valeur centrale lorsque l'on classe par ordre croissant un ensemble de valeurs.
         </p>
         <p>- <b>Moyenne</b> : la moyenne d'un ensemble de valeurs est leur somme divis&eacute;e par leur nombre.
         </p>
         <p>- <b>Niveaux de gris</b> : nuances de gris utilis&eacute;es pour afficher &agrave; l'&eacute;cran une image num&eacute;rique.
         </p>
         <p>- <b>Nombres entiers</b> : nombres 0, 1, 2, 3, 4 ...
         </p>
         <p>- <b>Octet</b> : ensemble de huit bits cons&eacute;cutifs.
         </p>
         <p>- <b>Ondelettes</b> : transformation de l'image qui est utilis&eacute;e par la m&eacute;thode JPEG-2000 de compression d'images.
         </p>
         <p>- <b>Ordre croissant</b> : classement d'un ensemble de valeurs de la plus petite &agrave; la plus grande.
         </p>
         <p>- <b>Pixel</b> : une case dans un tableau de valeurs correspondant &agrave; une image num&eacute;rique.
         </p>
         <p>- <b>Quantification</b> : proc&eacute;d&eacute; consistant &agrave; r&eacute;duire l'ensemble des valeurs possibles d'une image num&eacute;rique.
         </p>
         <p>- <b>Racine carr&eacute;e</b> : la racine carr&eacute;e \(b\) d'une valeur positive \(a\) est la valeur positive \(b\) v&eacute;rifiant \(a=b \times b\). On la note
            \(\sqrt{a}\).
         </p>
         <p>- <b>R&eacute;solution</b> : taille d'une image (nombre de pixels).
         </p>
         <p>- <b>Sous-expos&eacute;e</b> : photographie d'une sc&egrave;ne trop sombre pour laquelle l'objectif photographique n'est pas rest&eacute; assez longtemps ouvert.
         </p>
         <p>- <b>Synth&egrave;se additive</b> : r&egrave;gle permettant de construire une couleur quelconque &agrave; partir des trois couleurs rouge, vert et bleu. C'est la r&egrave;gle qui
            r&eacute;git le m&eacute;lange des couleurs de faisceaux lumineux utilis&eacute;s pour l'&eacute;clairage d'un mur blanc.
         </p>
         <p>- <b>Synth&egrave;se soustractive</b> : r&egrave;gle permettant de construire une couleur quelconque &agrave; partir des trois couleurs cyan, magenta et jaune. C'est la r&egrave;gle
            qui r&eacute;git le m&eacute;lange des couleurs en peinture.
         </p>
         <p class="footer"><br>
            Copyright  (c) 2010 Gabriel Peyre<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Le traitement numrique des images
% Cette page reprend
% <http://images.math.cnrs.fr/Le-traitement-numerique-des-images.html
% l'article publi sur le site web Images des mathmatiques>.

%%
% Les appareils numriques photographient de manire trs prcise le monde
% qui nous entoure. L'utilisateur souhaite pouvoir stocker avec un encombrement
% minimal ses photos sur son disque dur. Il souhaite galement pouvoir les retoucher
% afin d'amliorer leur qualit. Cet article prsente les outils mathmatiques et 
% informatiques qui permettent d'effectuer ces diffrentes tches.

%%
% Cet article prsente quelques concepts du <http://fr.wikipedia.org/wiki/Traitement_d'images traitement> 
% mathmatique des
% images numriques. Ces traitements permettent de stocker plus facilement 
% les images et d'amliorer leur qualit. Les mathmatiques utilises dans 
% cet article correspondent au niveau de la classe de troisime. Les mots 
% cls en rouge pointent vers les pages <http://fr.wikipedia.org/ Wikipdia> 
% correspondantes. Ils sont 
% repris  la fin de l'article dans un glossaire.

%%
% _Mot clefs :_ image, bits, carr, racine carre, inverse, logarithme, moyenne, mdiane.

%% Installing toolboxes and setting up the path.

%%
% You need to download the following files: 
% <../toolbox_signal.zip signal toolbox> and 
% <../toolbox_general.zip general toolbox>.

%%
% You need to unzip these toolboxes in your working directory, so
% that you have 
% |toolbox_signal| and 
% |toolbox_general|
% in your directory.

%%
% *For Scilab user:* you must replace the Matlab comment '%' by its Scilab
% counterpart '//'.

%%
% *Recommandation:* You should create a text file named for instance |numericaltour.sce| (in Scilab) or |numericaltour.m| (in Matlab) to write all the
% Scilab/Matlab command you want to execute. Then, simply run |exec('numericaltour.sce');| (in Scilab) or |numericaltour;| (in Matlab) to run the commands. 

%%
% Execute this line only if you are using Matlab.

getd = @(p)path(p,path); % scilab users must *not* execute this

%%
% Then you can add the toolboxes to the path.

getd('toolbox_signal/');
getd('toolbox_general/');




%% Les pixels d'une image
% Une <http://fr.wikipedia.org/wiki/Image_num%C3%A9rique image numrique>
% en niveaux de gris est un tableau de valeurs. Chaque
% case de ce tableau, qui stocke une valeur, se nomme un <http://fr.wikipedia.org/wiki/Pixel pixel>. 
% En notant \(n\) le nombre de lignes et \(p\) le nombre de colonnes de l'image, 
% on manipule ainsi un tableau de \(n \times p\) pixels.


%% 
% La figure ci-dessous montre une visualisation d'un tableau carr avec 
% \(n=p=240\), ce qui reprsente  \(240\times 240\)=57600 pixels. Les
% <http://fr.wikipedia.org/wiki/Appareil_photographique_num%C3%A9rique appareils photos numriques> 
% peuvent enregistrer des images beaucoup plus grandes,
% avec plusieurs <http://en.wikipedia.org/wiki/Gigapixel_image millions de pixels>.

n = 256;
name = 'hibiscus';
f = load_image(name, n);
f = rescale(sum(f,3));
clf;
imageplot(f);


%%
% Les valeurs des pixels sont enregistres dans <http://fr.wikipedia.org/wiki/Ordinateur l'ordinateur> ou
% <http://fr.wikipedia.org/wiki/Appareil_photographique_num%C3%A9rique l'appareil photo numrique> 
% sous forme 
% de <http://fr.wikipedia.org/wiki/Entier_relatif nombres entiers> entre 0 et 255, 
% ce qui fait 256 valeurs possibles pour chaque pixel.

%%
% La valeur 0 correspond au noir, et la valeur 255 correspond au blanc. Les
% valeurs intermdiaires correspondent  des <http://fr.wikipedia.org/wiki/Niveau_de_gris niveaux de gris>
% allant du noir au blanc.

%%
% La figure ci-dessous montre un sous-tableau de \(6 \times 6\) pixels extrait de
% l'image prcdente. On peut voir  la fois les valeurs qui composent le tableau et les niveaux de gris qui permettent d'afficher l'image  l'cran.

selx = 19:24;
sely = 62:67;
clf;
image(f(selx,sely)*255); axis image; axis off;
disp(floor(255*f(selx,sely)));



%%
% Les valeurs de l'images extraite sont:
% \[
% \left[
% \begin{array}{ccc}
%   43    &43   & 43  &  41  &  40 &   39 \\
%   48    &49   & 46  &  42 &   44  &  43\\
%   110   & 79  &  54 &   47  &  48 &   45\\
%   190   &192  & 190  & 153  &  99 &   54\\
%   150   &166  & 189 &  203  & 183 &  170\\
%   131   &140  & 145 &  161  & 165 &  178\\
% \end{array}
% \right]
% \]

%% Stocker une image
% Stocker de grandes images sur le <http://fr.wikipedia.org/wiki/Disque_dur disque dur>
% d'un ordinateur prend
% beaucoup de place. Les nombres entiers sont stocks 
% en <http://fr.wikipedia.org/wiki/Syst%C3%A8me_binaire criture binaire>, 
% c'est--dire sous la forme d'une succession
% de 0 et de 1. Chaque 0 et chaque 1 se stocke sur une unit lmentaire
% de stockage, appele <http://fr.wikipedia.org/wiki/Bit bit>.

%%
% Pour obtenir l'criture binaire d'un pixel ayant comme valeur 179, 
% il faut dcomposer cette valeur comme somme de puissances de deux. 
% On obtient ainsi
% \[ 179=2^7+2^5+2^4+2+1, \]
% o l'on a pris soin d'ordonner les puissances de deux par ordre
% dcroissant. Afin de faire mieux apparatre l'criture binaire, 
% on ajoute "\(1 \times\)" devant chaque puissance qui apparat dans l'criture, 
% et "\(0\times\)" devant les puissances qui n'apparaissent pas
% \[ 179=1 \times 2^7 + 0 \times 26 + 1 \times 2^5 + 1 \times 24 + 
%   0 \times 2^3 + 0 \times 22 + 1 \times 2^1 + 1 \times 2^0. \]

%%
% Avec une telle criture, 
% la valeur de chaque pixel, qui est un nombre entre 0 et 255, ncessite 
% \[ \log_2(256) = 8 \text{ bits}. \]
% La fonction \(\log_2\) est le logarithme en base 2, et ce calcul exprime
% le fait que 
% \[ 256=2^8 = 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2.  \]
% L'criture binaire de la valeur 179 du pixel est ainsi \((1,0,1,1,0,0,1,1)\),
% o chaque 1 et chaque 0 correspond au facteur multiplicatif qui apparat devant chaque puissance.

%%
% On peut crire toute valeur entre 0 et 255 de cet manire,
% ce qui ncessite d'utilisation de 8 bits. Il y a en effet 
% 256 valeurs possibles, et \(256=2^8\). Pour stocker l'image complte, on a donc besoin de
% \[ n \times p \times 8 \text{ bits}. \]

%%
% Pour stocker l'image complte, on a donc besoin de 
% \[ n \times p \times 8  \text{ bits}. \]
% Pour l'image montre aux figure prcdentes, on a ainsi besoin de 
% \[ 256 \times 256 \times 8 = 524288 \text{ bits}. \]

%%
% Pour l'image montre  la premire figure, on a ainsi besoin de
% \[ 240 \times 240 \times 8 = 460800 \text{ bits.} \]
% On utilise le plus souvent <http://fr.wikipedia.org/wiki/Octet l'octet> (8 bits) comme unit,
% de sorte que cette image ncessite 57,6ko (kilo octets).

%% La rsolution d'une image
% Afin de rduire la place de stockage d'une image, on peut rduire sa
% <http://fr.wikipedia.org/wiki/R%C3%A9solution_(imagerie_num%C3%A9rique) rsolution>, 
% c'est--dire diminuer le nombre de pixels.

%%
% La faon la plus simple d'effectuer cette rduction consiste  supprimer des lignes et des colonnes dans l'image de dpart.

%%
% La figure suivante montre ce que l'on obtient si l'on retient une ligne sur 4 et une colonne sur 4.

sub = @(f,k)f(1:k:end,1:k:end);

clf;
imageplot(sub(f,4));



%%
% On a ainsi divis par \(4 \times 4 = 16\) le nombre de pixels de l'image,
% et donc galement rduit par 16 le nombre de bit ncessaire pour stocker l'image sur 
% un disque dur.

%%
% La figure suivante montre les rsultats obtenus en enlevant de plus en
% plus de lignes et de colonnes. Bien entendu, la qualit de l'image se
% dgrade vite.


klist = [2 4 8 16];
clf;
for i=1:length(klist)
    k = klist(i);
    imageplot(clamp(sub(f,k)), ['1 ligne/colonne sur ' num2str(k)], 2, 2, i);
end





%% Quantifier une image
% Une autre faon de rduire la place mmoire ncessaire pour le stockage
% consiste  utiliser moins de nombres entirers pour chaque valeur.

%%
% On peut par exemple utiliser uniquement des nombres entier entre 0 et 3,
% ce qui donnera une image avec uniquement 4 niveau de gris. 

%%
% On peut effectuer une conversion de l'image d'origine vers une image avec
% 3 niveau de valeurs en effectuant les remplacements:

%%
% - les valeurs dans \(0,1,\ldots,63\) sont remplaces par la valeur 0, 
%
% - les valeurs dans \(64,1,\ldots,127\) sont remplaces par la valeur 1, 
%
% - les valeurs dans \(128,1,\ldots,191\) sont remplaces par la valeur 2, 
%
% - les valeurs dans \(192,\ldots,255\) sont remplaces par la valeur 3.

%%
% Une telle opration se nomme <http://fr.wikipedia.org/wiki/Quantification_(signal) quantification>.

%%
% La figure suivante montre l'image rsultante avec 4 niveaux de couleurs.
% Les 4 valeurs sont affiches en utilisant 4 niveaux de gris allant du noir
% au blanc.


quant = @(f,q)(round(q*rescale(f,1e-3,1-1e-3)-1/2)+1/2)/q;
clf;
imageplot(quant(f,4), '4 niveaux de gris');


%%
% Nous avons dj vu que l'on pouvait reprsenter toute valeur entre 0 et
% 255  l'aide de 8 bits en utilisant l'criture binaire. De faon similaire, 
% on vrifie que toute valeur entre 0 et 3 peut se reprsenter  l'aide de 2 bits. 
% On obtient ainsi une rduction d'un facteur 8/2=4 de la place 
% <http://fr.wikipedia.org/wiki/M%C3%A9moire_(informatique) mmoire> ncessaire 
% pour le stockage de l'image sur un disque dur.

%%
% La figure suivante montre les rsultats obtenus en utilisant de moins en
% moins de niveaux de gris.

qlist = [16, 4, 3, 2];
clf;
for i=1:length(qlist)
    q = qlist(i);
    f1 = quant(f,q); f1(1)=0; f1(2)=1;
    imageplot(f1, [num2str(q) ' niveaux de gris' ], 2, 2, i);
end




%% 
% Tout comme pour la rduction du nombre de pixels, la rduction du nombre
% de niveaux de gris influe beaucoup sur la qualit de l'image. 
% Afin de rduire au maximum la taille d'une image sans modifier sa qualit,
% on utilise des mthodes plus complexes de 
% <http://fr.wikipedia.org/wiki/Compression_d%27image compression d'image>. La mthode 
% la plus efficace s'appelle
% <http://fr.wikipedia.org/wiki/Jpeg_2000 JPEG-2000>. 
% Elle utilise la thorie des <http://fr.wikipedia.org/wiki/Ondelettes ondelettes>.
% Pour en savoir plus  ce sujet, vous pouvez consuler cet 
% <http://images.math.cnrs.fr/Compression-d-image.html article d'Erwan Le
% Pennec>.

%% Enlever le bruit par moyennes locales
% Les images sont parfois de mauvaise qualit. Un exemple typique de dfaut
% est le <http://fr.wikipedia.org/wiki/Bruit_num%C3%A9rique bruit> 
% qui apparait quand une photo est 
% <http://fr.wikipedia.org/wiki/Exposition_(photographie) sous-expose>, c'est--dire
% qu'il n'y a pas assez de luminosit. Ce bruit se manifeste par de petites
% flucturation <http://fr.wikipedia.org/wiki/Suite_al%C3%A9atoire alatoires>
% des niveaux de gris. La figure ci-dessous montre
% une image bruite. 

name = 'boat';
f = rescale(load_image(name, n));
sigma = .08;
f = f + randn(n)*sigma;
clf;
imageplot(f);



%%
% Afin d'enlever le bruit dans les images, il convient de faire subir une
% modification aux valeurs de pixels. 
% L'opration la plus simple consiste  remplacer la valeur 
% \(a\) de chaque pixel par la <http://fr.wikipedia.org/wiki/Moyenne moyenne> de 
% \(a\) et des 8 valeurs \(b,c,d,e,f,g,h,i\) des 8 pixels voisins de a.

%%
% Les valeurs des pixels sont positionnes comme suit :
% \[
% \left[
% \begin{array}{ccc}
%       g & c & h \\
%       b & a & d \\
%       f & e & i
% \end{array}
% \right]
%   =
% \left[
% \begin{array}{ccc}
%       79 & 54 & 47 \\
%       192 & 190 & 153 \\
%       166 & 189 & 203
% \end{array}
% \right]
% \]

%%
% On obtient ainsi une image modifie en remplaant a par
% \[ \frac{a+b+c+d+e+f+g+h+i}{9} \]
% puisque l'on fait la moyenne de 9 valeurs.
% Dans notre exemple, cette moyenne vaut
% \[ \frac{190+192+79+54+47+153+203+189+166}{9} \approx 141,4. \]
% En effectuant cette opration pour chaque pixel, on supprime une partie 
% du bruit, car ce bruit est constitu de fluctuations alatoires, qui sont
% diminues par un calcul de moyennes. La figure ci-dessous montre l'effet d'un tel calcul.

%% 
% La figure ci-dessous montre l'effet d'un tel moyennage. 

filt_moy = @(f,k)perform_convolution(f,ones(2*k+1)/(2*k+1)^2,'sym');
clf;
imageplot(clamp(f), 'Image bruite', 1, 2, 1);
imageplot(clamp(filt_moy(f,1)), 'Image moyenne', 1, 2, 2);




%%
% Tout le bruit n'a pas t enlev par cette opration. Afin d'enlever plus
% de bruit, on peut moyenner plus de valeurs autour de chaque pixel.
% La figure suivante montre le rsultat obtenu en moyennant de plus en plus
% de valeurs. 

klist = [1 2 3 4];
clf;
for i=1:length(klist)
    k = klist(i);
    f1 = filt_moy(f,k);
    imageplot(clamp(f1), ['Moyenne de ' num2str((2*k+1)^2) ' pixels'], 2, 2, i);
end



%%
% Le moyennage des pixels est trs efficace pour enlever le bruit dans les
% images, malheureusement il dtruit galement une grande partie de
% l'information de l'image. on peut en effet s'appercevoir que les images
% obtenues par moyennage sont <http://fr.wikipedia.org/wiki/Flou,_nettet%C3%A9_et_contraste floues>. Ceci est en particulier visible prs
% des contours, qui ne sont pas nets.


%% Enlever le bruit par mdiane
% Afin de rduire ce flou, il faut remplacer le moyennage par une opration
% un peu plus complexe, que l'on nomme <http://fr.wikipedia.org/wiki/M%C3%A9diane mediane>. 

%%
% Etant donn la valeur \(a\) d'un pixel, et les valeurs
% \(b,c,d,e,f,g,h,i\), on commence par les classer 
% par <http://fr.wikipedia.org/wiki/Ordre_croissant ordre croissant>.

%%
% Dans l'exemple du voisinage de 9 pixels utilis  la section prcdente, 
% on obtient les 9 valeurs classes
% \[ 47,54,79,153,166,189,190,192,203. \]
% La mdiane des neuf valeurs \(a,b,c,d,e,f,g,h,i\)
% est la \(5^\text{e}\) valeur de ce classement (c'est--dire la 
% valeur centrale de ce classement).

%%
% Dans notre cas, la mdiane est donc 166. Notez que ce nombre est en gnral 
% diffrent de la moyenne, qui vaut, pour notre exemple 141,4.

%%
% La figure ci-dessous compare le dbruitage obtenu en effectuant la
% moyenne et la mdiane de 9 pixels voisins.


filt_med = @(f,k)perform_median_filtering(f,k);
clf;
imageplot(clamp(filt_moy(f,1)), 'Moyenne de 9 nombres', 1, 2, 1);
imageplot(clamp(filt_med(f,1)), 'Mdiane de 9 nombres', 1, 2, 2);



%%
% Afin d'enlever plus de bruit, il suffit de calculer la mdiane sur un
% nombre plus grand de pixels voisins, comme montr  la figure suivante.

klist = [1 2 3 4];
clf;
for i=1:length(klist)
    k = klist(i);
    f1 = filt_med(f,k);
    imageplot(clamp(f1), ['Mdiane de ' num2str((2*k+1)^2) ' pixels'], 2, 2, i);
end




%%
% On constate que cette mthode est plus performante que le calcul de
% moyennes, car les images rsultantes sont moins floues. Cependant, tout comme 
% avec le calcul de moyennes, si l'on prend des voisinages trop grands, on perd
% aussi de l'information de l'image, en particulier les bords des objets sont dgrads.


%% Dtecter les bords des objets
% Affin de localiser des objets dans les images, il est ncessaire de
% dtecter les <http://fr.wikipedia.org/wiki/D%C3%A9tection_de_contours bords>
% de ces objets. Ces bords correspondent  des 
% zones de l'image o les valeurs des pixels changent rapidement. C'est le
% cas par exemple lorsque l'on passe de la coque du bateau (qui est sombre,
% donc avec des valeurs petites)  la mer (qui est claire, donc avec des
% valeurs grandes).

%%
% Afin de quantifier combien un pixel avec une valeur \(a\) est un bord,
% on prend en compte les valeurs \(b,c,d,e\) de ses quatre voisins (deux
% horizontallement et deux verticalements). Dans le cas considr
% prcdemment, on obtient :
% \[
% \left[
% \begin{array}{ccc}
%        & c &  \\
%       b & a & d \\
%        & e & 
% \end{array}
% \right]
%   =
% \left[
% \begin{array}{ccc}
%        & 54 &  \\
%       192 & 190 & 153 \\
%        & 189 & 
% \end{array}
% \right]
% \]

%%
% Notons que l'on utilise ici seulement 4 voisins, ce qui est diffrent du
% calcul de moyennes et de mdianes o l'on utilisait 8 voisins. 
% Ceci est important afin de dtecter aussi prcisment que possible les bords des objets.

%%
% On calcule une valeur \(\ell\) suivant la formule
% \[ \ell = \sqrt{ (b-d)^2 + (c-e)^2 }.  \]
% Dans notre exemple, on obtient donc
% \[ \ell= \sqrt{(192 - 153)^2 + (189 - 54)^2 } = \sqrt{19746} \approx 140,5. \]

%%
% On peut remarquer que si \(\ell=0\), alors on a \(b=c\)
% et \(d=e\). Au contraire, si 
% \(\ell\) est grand, ceci signifie que les pixels voisins ont des valeurs trs
% diffrentes, le pixel considr est donc probablement sur le bord d'un objet. 

%%
% La figure suivante montre l'image obtenue en calculant la valeur \(\ell\)
% associe  chaque pixel. On a affich ces valeurs avec du noir quand
% \(\ell=0\),  du blanc quand \(\ell\) est grand, 
% et on a utilis des niveaux de gris intermdiaire pour les valeurs entre 0 et 1.

n = 256;
name = 'hibiscus';
f = load_image(name, n);
f = rescale(sum(f,3));

s1 = [1 1:n-1]; s2 = [2:n n];
edge = @(f)sqrt( ( f(s1,:) - f(s2,:) ).^2 + ( f(:,s1) - f(:,s2) ).^2 );

clf;
imageplot(f, 'Image', 1,2,1);
imageplot(edge(f), 'Carte de l', 1,2,2);


%%
% On peut voir que dans l'image de droite, les contours des objets
% ressortent en blanc, car ils correspondent aux grandes valeurs de \(\ell\).

%% Les images couleurs
% Une <http://fr.wikipedia.org/wiki/Couleur image couleur>
% est en ralit compose de trois images indpendantes,
% afin de reprsenter le
% <http://fr.wikipedia.org/wiki/Rouge_vert_bleu rouge, le vert, et le bleu>. 
% Chacune de ces trois
% image s'appelle un <http://fr.wikipedia.org/wiki/Codage_informatique_des_couleurs canal>.
% Cette reprsentation en rouge, vert et bleu mime le fonctionnement du
% systme visuel humain.

%%
% La figure suivante montre une image couleur, qui est dcompose en ses
% trois canaux constitutifs.

name = 'hibiscus';
f = rescale( load_image(name,n) );
    
    
f1 = cat(3, f(:,:,1), zeros(n), zeros(n));
f2 = cat(3, zeros(n), f(:,:,2), zeros(n));
f3 = cat(3, zeros(n), zeros(n), f(:,:,3));

clf;
imageplot({f f1 f2 f3}, ...
        { 'Image couleur' 'Canal rouge' 'Canal vert' 'Canal bleu'}, 2, 2);



%%
% Chaque pixel de l'image couleur contient ainsi trois nombres \( (r,v,b) \),
% chacun tant un nombre entier entre 0 et 255.
% Si le pixel est gal  \((r,v,b)=(255,0,0)\), il ne contient que de l'information
% rouge, et est affich comme du rouge. 
% De faon similaire, les pixels valant \((0,255,0)\) et \((0,0,255)\) sont
% respectivement affichs vert et bleu.

%%
% On peut afficher  l'cran une image couleur 
% partir de ses trois canaux \((r,v,b)\) en utilisant les rgles de la 
% <http://fr.wikipedia.org/wiki/Synth%C3%A8se_additive synthse additive des couleurs>. 
% La figure suivante montre les rgles de composition
% cette synthse additive des couleurs. 
% Par exemple un pixel avec les valeurs
% \((r,v,b)=(255,0,255)\) est un mlange de rouge et de vert, il est donc
% affich comme du jaune.

%%
% On peut calculer une image en niveau de gris  partir d'une image couleur
% en moyennant les trois cannaux. On calcule donc une valeur 
% \[ a = \frac{r+v+b}{3} \]
% qui s'appelle la <http://fr.wikipedia.org/wiki/Luminance luminance> de la couleur.

%%
% La figure suivante montre le passage d'une image couleur  une image de luminance en
% niveau de gris.

clf;
imageplot({f sum(f,3)}, {'Couleur' 'Luminance'});

%%
% Une autre reprsentation courante pour les images couleurs utilise
% comme couleurs de base le cyan, le magenta et le jaune. On calcule 
% les trois nombres \((c,m,j)\) correspondant  chacun de ces trois canaux  
% partir des canaux rouge, vert et bleu \((r,v,b)\) comme suit
% \[ c=255-r, \quad m=255-v, \quad j=255-b. \]
% Par exemple, un pixel de bleu pur 
% \((r,v,b)=(0,0,255)\) va devenir 
% \( (c,m,j)=(255,255,0) \). La figure suivante montre les trois canaux
% \((c,m,j)\) d'une image couleur.

g = 1-f;
f1 = cat(3, f(:,:,1),     f(:,:,2)*0+1, f(:,:,3)*0+1);
f2 = cat(3, f(:,:,1)*0+1, f(:,:,2)    , f(:,:,3)*0+1);
f3 = cat(3, f(:,:,1)*0+1, f(:,:,2)*0+1, f(:,:,3));


clf;
imageplot({f f1 f2 f3}, ...
        { 'Image couleur' 'Canal cyan' 'Canal magenta' 'Canal jaune'}, 2, 2);


%%
% Afin d'afficher une image couleur  l'cran  partir des trois canaux
% \((c,m,j)\), on doit utiliser la synthse soustractive des 
% couleurs. La figure suivante montre les rgles de composition 
% cette synthse soustractive. Notons que ces rgles sont celles que
% l'on utilise en peinture, lorsque l'on mlange des pigments colors. Le cyan,
% le magenta et le jaune sont appels couleurs primaires.


%%
% On peut donc stocker sur un disque dur une image couleur en stockant les
% trois canaux, correspondant aux valeurs \((r,g,b)\) ou \((c,m,j)\). 
% On peut modifier les images couleur tout comme les images en niveaux de
% gris. La faon la plus simple de procder consiste  appliquer la modification
%  chacun des canaux.


%% Changer le contraste d'une image
% Il est possible de faire subir diffrentes modifications  l'image afin de
% changer son <http://fr.wikipedia.org/wiki/Contraste contraste>.

name = 'hibiscus';
f = rescale( load_image(name,n) );
f = rescale(sum(f,3));

%%
% Un exemple simple consiste  remplacer chaque valeur \(a\) d'un pixel
% d'une image par \(255-a\) ce qui correspond  la couleur oppose. Le blanc
% devient noir et vice-et-versa, ce qui donne un effet similaire  celui
% des <http://fr.wikipedia.org/wiki/Film_n%C3%A9gatif ngatifs>
% <http://fr.wikipedia.org/wiki/Argentique d'appareils photos argentiques>.

clf;
imageplot(-f);


%%
% Sans aller jusqu' des modifications aussi extrmes, on peut assombrir une image 
% en remplant la valeur \(a\) de chaque pixel par son 
% <http://fr.wikipedia.org/wiki/Carr%C3%A9_(alg%C3%A8bre) carr> \(a^2 = a \times a\). 

%% 
% Ce faisant, les valeurs rsultantes ne sont 
% plus dans \(0,\ldots,255\) mais dans \(0,\ldots,255^2=65025\). Afin
% d'afficher l'image  l'cran on va donc utiliser des niveaux de gris
% allant du noir pour 0 au blanc pour 65025.

clf;
imageplot(f.^2, 'Carr');



%%
% Afin d'claircir l'image, on peut remplacer chaque valeur \(a\) par
% sa _racine carre_ \(b = \sqrt{a}\). Cette valeur \(b\) est un nombre, qui n'est plus
% ncessairement entier, qui satisfait \(b \times b = a\).

%%
% La figure suivante montre l'claircissement obtenu. 
% Les valeurs de l'image claircie sont dant 
% \(0,\ldots,\sqrt{255} \approx 16\), et on utilise donc des niveaux
% de gris allant du noir (pour 0) au blanc (pour 16).

clf;
imageplot(sqrt(f), 'Remplacement de a par sqrt(a)');


%%
% On pourra noter que l'on a 
% \[ \sqrt{a} \times \sqrt{a} = a
% \quad\text{et}\quad \sqrt{a \times a}=a \]
% de sorte que si l'on ralise un clairsissement suivit d'un
% assombrissement (ou dans le sens inverse) on retrouve l'image d'origine.
% Ces deux oprations sont 
% <http://fr.wikipedia.org/wiki/Inverse inverses> l'une de l'autre. 

%%
% On peut galement changer le contraste d'une image couleur en changeant sa
% composante de luminance. 

name = 'hibiscus';
f = rescale( load_image(name,n) );

m = @(f)repmat(mean(f,3), [1 1 3]);
contrast = @(f,gamma)clamp(m(f).^gamma + f-m(f));

gamma_list = [.5 .75 1 1.5 2 3];
clf;
for i=1:length(gamma_list)
    subplot(2,3,i);
    image(contrast(f,gamma_list(i))); axis image; axis off;
    title(['\gamma=' num2str(gamma_list(i))]);
    colormap jet(256);
end




%% Transformations gomtriques
% Une image est un tableau de nombres, avec \(n\) lignes et \(p\) 
% colonnes. Il est donc facile d'effectuer
% certaines <http://fr.wikipedia.org/wiki/Transformation_g%C3%A9om%C3%A9trique transformations gomtriques>
% sur l'image.

%%
% Les valeurs des pixels qui composent ce tableau (not \(A\)) peuvent tre 
% reprsentes sous la forme \( A = ( a_{i,j} )_{i,j} \)
% ou l'index \(i\) dcrit l'ensemble des nombres \( \{1,\ldots,n\} \)
% (les entiers entre 1 et n) et l'index 
% \(j\) les nombres \( \{1,\ldots,p\} \).
% One dit que \(a_{i,j}\) est la valeur du pixel  la position \((i,j)\).

%%
% Le tableau de pixels ainsi index peut se reprsenter sous la faon
% suivante
% \[
% A = 
% \begin{pmatrix}
% a_{1,1} &           &           &   & a_{1,p}\\
%        &           &  \vdots   &   &  \\
% 	   &           & a_{i-1,j} &   & \\
% \ldots & a_{i,j-1} & a_{i,j}   & a_{i,j+1} & \ldots\\
% 	   &           & a_{i+1,j} &   & \\
%        &           &  \vdots   &   &  \\
% a_{n,1} &           &           &   & a_{n,p}\\
% \end{pmatrix}
% \]
% ce qui montre que le pixel en haut  gauche de l'image correspond  la
% valeur \(a_{1,1}\). Ceci correspond  la reprsentation de l'image sous
% forme d'une <http://fr.wikipedia.org/wiki/Matrice_(math%C3%A9matiques) matrice>.

%%
% Si l'on change le rle des lignes et des colonnes, on dfinit un autre
% tableau \(B\) avec \(p\) lignes et \(n\) colonnes. La formule qui dfinit
% le tableau \(B = ( b_{j,i} )_{i,j}\) est 
% \[ b_{j,i} = a_{i,j}. \]
% Ceci correspond  la <http://fr.wikipedia.org/wiki/Matrice_transpos%C3%A9e transposition> de la matrice correspondant  l'image.

%%
% Pour une image couleur, on effectue cette modification sur chacune de ses
% trois composantes couleur R, V et B.

%%
% La figure suivante montre l'image correspondant au tableau \(A\) et
% l'image correspondant au tableau \(B\). On peut constater que la
% modification correspond  faire sur l'image une 
% <http://fr.wikipedia.org/wiki/Sym%C3%A9trie_(transformation_g%C3%A9om%C3%A9trique) symtrie> par rapport 
% la <http://fr.wikipedia.org/wiki/Diagonale diagonale>
% qui joint le coin haut/gauche au coin bas/droite.

A = rescale( load_image('flowers',512) );
B = permute(A, [2 1 3]);
clf;
imageplot({A B}, {'Image A' 'Image B'}, 1,2,1);




%%
% On peut galement effectuer une <http://fr.wikipedia.org/wiki/Rotation rotation> 
% d'un quart de tour dans le sens d'une montre 
% l'image. Ceci est effectu en dfinissant une image \(C = (c_{i,j})_{j,i}\) de 
% \(p\) lignes et \(n\)
% colonnes dont le tableau
% de nombre est calcul par
% \[ c_{j,i} =  a_{n-i+1,j}.\]

C = A;
C = C(end:-1:1,:,:); C = permute(C, [2 1 3]); 
clf;
imageplot({A C}, {'Image A' 'Image C'}, 1,2,1);



%% Fondu entres deux images
% On souhaite effectuer une <http://fr.wikipedia.org/wiki/Fondu transition entre deux images>
% \(A\) et \(B\) de mme
% taille. On suppose donc que chaque image a le mme nombre \(n\) de lignes
% et le mme nombre \(p\) de colonnes.

%%
% La figure ci-dessous montre les deux images entre lesquelles on souhaite
% calculer une transition.

A = rescale( load_image('flowers',512) );
B = rescale( load_image('hibiscus',512) );
clf;
imageplot({A B}, {'Image A', 'Image B'});

%%
% One note \(A = (a_{i,j})_{i,j}\) les pixels de l'image \(A\) et 
% \(B = (b_{i,j})_{i,j}\) les pixels de l'image \(B\).

%%
% Pour une valeur \(t\) fixe entre \(0\) et \(1\), on dfinit l'image
% \(C = (c_{i,j})_{i,j}\) comme 
% \[ c_{i,j}  = (1-t) a_{i,j} + t b_{i,j}.\]
% Il s'agit de la formule d'une 
% <http://fr.wikipedia.org/wiki/Interpolation_lin%C3%A9aire interpolation linaire>
% entre les deux images.

%%
% Si l'image est une image couleur, on applique cette formule  chacun des
% canaux R, V et B.

%%
% On peut constater que pour \(t=0\), l'image \(C\) est gale  l'image
% \(A\). Pour \(t=1\), l'image \(c\) est gale  l'image
% \(B\). Lorsque la valeur \(t\) progresse de 0  1, on obtient ainsi un
% effet de fondu, puisque l'image, qui au dpart est proche de l'image \(A\)
% ressemble de plus en plus  l'image \(B\).

%%
% La figure suivante montre 5 valeurs de \(t\) rparties entre 0 et 1.

p = 6;
t = linspace(0,1,p);
clf;
for i=1:p
    imageplot(t(i)*A+(1-t(i))*B, ['t=' num2str(t(i), 2)], 2,p/2,i);
end


%% Conclusion
% Cet article n'a fait qu'effleurer l'immense liste des traitements que l'on 
% peut faire subir  une image. Le traitement mathmatique des images est un domaine
% trs actif, o les avances thoriques se concrtisent sous la forme d'algorithmes 
% rapides de calcul qui ont des applications importantes pour la manipulation des contenus
% numriques.

%%
% Les personnes intresses pourront consulter le site web 
% <http://www.numerical-tours.com/ A Numerical Tour of Signal Processing> 
% pour de nombreux exemples de traitements d'images. On y 
% trouve galement des liens vers d'autres ressources disponibles en ligne.

%% Glossaire

%%
% - *Alatoire* : valeur imprvisible souvent due au hazard, comme par exemple le bruit qui perturbe les images de mauvaises qualits.
%
% - *Bit* : unit lementaire de stockage de l'information sous forme de 0 et de 1 dans un ordinateur.
%
% - *Canal* : une des trois images lmentaires qui composent une image couleur.
%
% - *Bords* : zone d'une image o les valeurs des pixels varient beaucoup, qui correspond aux contours des objets qui forment l'image.
%
% - *Bruit* : petites perturbations qui dgradent la qualit d'une image.
%
% - *Carr* : le carr \(b\) d'une valeur \(a\) est \(a \times a\). Il est not \(a^2\).
%
% - *Contraste* : quantit informelle qui indique la diffrence entre les zones claires et les zones sombres d'une image.
%
% - *Compression d'image* : mthode permettant de rduire la place mmoire ncessaire au stockage sur le disque dur d'une image.
%
% - *Ecriture binaire* : criture de valeurs numriques  l'aide uniquement de 0 et de 1.
%
% - *Flou* : dgradation d'une image qui rend les contours des objets peu net, et donc difficile  localiser prcisment.
%
% - *Fondu* : interpolation linaire entre deux images.
%
% - *Image couleur* : ensemble de trois images en niveau de gris, qui peut tre affich  l'cran en couleur.
%
% - *Image numrique* : tableau de valeurs que l'on peut afficher  l'cran en assignant un niveau de gris  chaque valeur.
%
% - *Inverse* : opration ramenant une image dans son tat d'origine.
%
% - *JPEG-2000* : mthode rcente de compression d'images qui utilise une transformation en ondelettes.
%
% - *Luminance* : moyenne des diffrents canaux d'une image, qui indique la puissance lumineuse du pixel.
%
% - *Matrice* : tableau de valeurs, reprsent sous la forme \((a_{i,j})_{i,j}\).
%
% - *Mdiane* : valeur centrale lorsque l'on classe par ordre croissant un ensemble de valeurs.
%
% - *Moyenne* : la moyenne d'un ensemble de valeurs est leur somme divise par leur nombre.
%
% - *Niveaux de gris* : nuances de gris utilises pour afficher  l'cran une image numrique.
%
% - *Nombres entiers* : nombres 0, 1, 2, 3, 4 ...
%
% - *Octet* : ensemble de huit bits conscutifs.
%
% - *Ondelettes* : transformation de l'image qui est utilise par la mthode JPEG-2000 de compression d'images.
%
% - *Ordre croissant* : classement d'un ensemble de valeurs de la plus petite  la plus grande.
%
% - *Pixel* : une case dans un tableau de valeurs correspondant  une image numrique.
%
% - *Quantification* : procd consistant  rduire l'ensemble des valeurs possibles d'une image numrique.
%
% - *Racine carre* : la racine carre \(b\) d'une valeur positive \(a\) est la valeur positive \(b\) vrifiant \(a=b \times b\). On la note \(\sqrt{a}\).
%
% - *Rsolution* : taille d'une image (nombre de pixels).
%
% - *Sous-expose* : photographie d'une scne trop sombre pour laquelle l'objectif photographique n'est pas rest assez longtemps ouvert.
%
% - *Synthse additive* : rgle permettant de construire une couleur quelconque  partir des trois couleurs rouge, vert et bleu. C'est la rgle qui rgit le mlange des couleurs de faisceaux lumineux utiliss pour l'clairage d'un mur blanc.
%
% - *Synthse soustractive* : rgle permettant de construire une couleur quelconque  partir des trois couleurs cyan, magenta et jaune. C'est la rgle qui rgit le mlange des couleurs en peinture.


##### SOURCE END #####
-->
   </body>
</html>